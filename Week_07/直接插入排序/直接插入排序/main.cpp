//
//  main.cpp
//  直接插入排序
//
//  Created by YJLi on 2021/2/1.
//

#include <iostream>
#include <vector>

using namespace std;

/*
 直接插入排序的基本操作是将一个记录插入到已经排好序的有序表中，从而得到一个新的、记录数增1的有序表
 */

/*
 插入排序：
 从前到后逐步构建有序序列；对于未排序数据，在已排序序列从后向前扫描，找到相应位置并插入。
 */

class Solution {
    
public:
    
    /*
     下面举个例子，初始数组 {12, 15, 9, 20, 6, 31, 24}

     我们把第一个元素12作为已经排序号的数组，用中括号括起来，方便我们观察

     那么初始数组：[12], 15, 9, 20, 6, 31, 24

     第一步，拿着15和12比较，发现15大于12，把15插入到12后面，于是当前数组变成

          数组结果：[12, 15 ], 9, 20, 6, 31, 24

     第二步，拿着9和15比较，发现15>9,把15向后面移动一位，在把9和12比较发现12>9，把12向后移动一位，最后把9插入

          数组结果：[9,12, 15 ],  20, 6, 31, 24

     第三步，拿着20和15比较，发现15<20，不需要调整

          数组结果：[9,12, 15 ,20], 6, 31, 24

     如此执行下去，直到所有排序完成，

     */
    /*
     1、初始将序列分为已排序和待排序序列两部分，一般默认序列的第一个元素为已排序序列的第一个元素(也是最后一个元素，之所以作为最后一个元素看待其实就是在后续的插入操作中，从后向前逐次比较已经排好的序列)
     2、这里关键的点在于若是当前待排序的关键字小于从后向前已排序的某个记录值，将这个已排序的记录值向后移动一位，逐个移动直到找到合适的位置插入待排序的的元素！！！
     */
    void InsertSort(vector<int> &nums) {
        for (int i = 1; i < nums.size(); i++) {
            int key = nums[i];//待排序的第一个元素
            int j = i - 1;//已经排过序的最后一个元素
            while (j >= 0 && key < nums[j]) {
                //从已经排序的序列后向前逐个比较已经排序过数组，如果比它小，则把后者用前者代替，
                //其实说白了就是数组逐个后移动一位,为找到合适的位置时候便于Key的插入
                nums[j+1] = nums[j];
                j--;
            }
            /*
             我觉得这个赋值的写法用的很妙，这里将关键字插入到相对比较小的元素后面
             当 判断 j == 0 索引的关键字大于待排序的记录，再循环一次j == -1，不满足循环条件，将待排序的记录插入到不满足索引的记录后面，即是索引 0 的位置，也是已排序的第一个元素位置，所以我觉得用的很妙
             */
            nums[j+1] = key;//找到合适的位置了，在索引 j 的后面设置 j 的值
        }
    }
    /*
     时间复杂度：

     */
    
};

int main(int argc, const char * argv[]) {
    // insert code here...
    std::cout << "Hello, World!\n";
    
    Solution solu;
    vector<int> vec = {12, 15, 9, 20, 6, 31, 24 };
    solu.InsertSort(vec);
    for (int i = 0; i < vec.size(); i++) {
        cout<<vec[i]<<" ";
    }
    
    cout<<endl;
    std::cout << "Hello, World!\n";
    return 0;
}
